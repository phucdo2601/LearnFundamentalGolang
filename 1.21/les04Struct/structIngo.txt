STRUCTS IN GO
We use structs in Go to represent structured data. It's often convenient to group different types of variables together. For example, if we want to represent a car we could do the following:

type car struct {
  Make string
  Model string
  Height int
  Width int
}

This creates a new struct type called car. All cars have a Make, Model, Height and Width.

In Go, you will often use a struct to represent information that you would have used a dictionary for in Python, or an object literal for in JavaScript.
----------------------------------------------------------------------------
Pointers to a struct
Pointers in Go programming language or Golang is a variable which is used to store the memory address of another variable. You can also create a pointer to a struct as shown in the below example: 
// Golang program to illustrate
// the pointer to struct

package main

import "fmt"

// defining a structure
type Employee struct {
	firstName, lastName string
	age, salary int
}

func main() {

	// passing the address of struct variable
	// emp8 is a pointer to the Employee struct
	emp8 := &Employee{"Sam", "Anderson", 55, 6000}

	// (*emp8).firstName is the syntax to access
	// the firstName field of the emp8 struct
	fmt.Println("First Name:", (*emp8).firstName)
	fmt.Println("Age:", (*emp8).age)
}

Output:

First Name: Sam
Age: 55

The Golang gives us the option to use emp8.firstName instead of the explicit dereference (*emp8).firstName to access the firstName field. Example to show this is following: 

// Golang program to illustrate
// the pointer to struct
package main

import "fmt"

// Defining a structure
type Employee struct {
	firstName, lastName string
	age, salary		 int
}

// Main Function
func main() {

	// taking pointer to struct
	emp8 := &Employee{"Sam", "Anderson", 55, 6000}

	// emp8.firstName is used to access
	// the field firstName
	fmt.Println("First Name: ", emp8.firstName)
	fmt.Println("Age: ", emp8.age)
}

In Go, a structure is a composite data type that groups together zero or more values of different types. Structures are defined using the type keyword, followed by the name of the new type, and the keyword struct. Here’s an example:

In this example, we define a new type Person that has three fields: Name of type string, Age of type int, and Address of type string. We can then create new instances of the Person type and set the values of its fields:

func main() {
	person := Person{
		Name: "John Doe",
		Age:	 30,
		Address: "123 Main St",
	}
	fmt.Println(person)
}

Output:
{John Doe 30 123 Main St}
 

    Advantages of using structures in Go:
        Encapsulation: Structures allow you to encapsulate related data together, making it easier to manage and modify the data.
        Code organization: Structures help to organize code in a logical way, which makes it easier to read and maintain.
        Flexibility: Structures allow you to define custom types with their own behavior, making it easier to work with complex data.
        Type safety: Structures provide type safety by allowing you to define the type of each field, which helps to prevent errors caused by assigning the wrong type of value.
        Efficiency: Structures in Go are very efficient, both in terms of memory usage and performance.

    Disadvantages of using structures in Go:
        Complexity: Structures can make code more complex, especially if the structures have a large number of fields or methods.
        Boilerplate code: When defining large structures with many fields, it can be time-consuming to write out all of the field names and types.
        Inheritance: Go does not support inheritance, which can make it more difficult to work with large hierarchies of related data.
        Immutability: Go structures are mutable by default, which can make it more difficult to enforce immutability in your code.

Overall, the advantages of using structures in Go typically outweigh the disadvantages, as they provide a powerful tool for managing and working with complex data. However, as with any programming technique, it’s important to use structures judiciously and be aware of their limitations.
Here are some important points about structures in Go:
Structures are composite data types that allow you to group together related data of different types.
In Go, structures are defined using the type keyword, followed by the name of the new type, and the keyword struct.
Structures can have fields that are of any type, including other structures.
Fields can be accessed using the dot . operator.
Structures in Go can also have methods associated with them.
Methods can be defined on structures using the receiver syntax.
Structures can be used to create custom types that encapsulate related data and behavior.
Go structures are mutable by default, but you can create immutable structures by using pointers or methods that return a new instance of the structure.
Structures in Go are very efficient in terms of both memory usage and performance.
Go does not support inheritance, but you can use composition to achieve similar results.
Overall, structures in Go are a powerful tool for managing and working with complex data. By grouping related data together and associating behavior with it, you can create custom types that are more expressive and easier to work with.

------------------------------------------------------------------------------------------------------------------------
NESTED STRUCTS IN GO
Structs can be nested to represent more complex entities:

type car struct {
  Make string
  Model string
  Height int
  Width int
  FrontWheel Wheel
  BackWheel Wheel
}

type Wheel struct {
  Radius int
  Material string
}

The fields of a struct can be accessed using the dot . operator.

myCar := car{}
myCar.FrontWheel.Radius = 5

ASSIGNMENT
Textio has a bug, we've been sending texts with information missing! Before we send text messages in Textio, we should check to make sure the required fields have non-zero values.

Notice that the user struct is a nested struct within the messageToSend struct. Both sender and recipient are user struct types.

Complete the canSendMessage function. It should return true only if the sender and recipient fields each contain a name and a number. If any of the default zero values are present, return false instead.

------------------------------------------------------------------------------------------------------------------------
ANONYMOUS STRUCTS IN GO
An anonymous struct is just like a normal struct, but it is defined without a name and therefore cannot be referenced elsewhere in the code.

To create an anonymous struct, just instantiate the instance immediately using a second pair of brackets after declaring the type:

myCar := struct {
  Make string
  Model string
} {
  Make: "tesla",
  Model: "model 3",
}

You can even nest anonymous structs as fields within other structs:

type car struct {
  Make string
  Model string
  Height int
  Width int
  // Wheel is a field containing an anonymous struct
  Wheel struct {
    Radius int
    Material string
  }
}

WHEN SHOULD YOU USE AN ANONYMOUS STRUCT?
In general, prefer named structs. Named structs make it easier to read and understand your code, and they have the nice side-effect of being reusable. I sometimes use anonymous structs when I know I won't ever need to use a struct again. For example, sometimes I'll use one to create the shape of some JSON data in HTTP handlers.

If a struct is only meant to be used once, then it makes sense to declare it in such a way that developers down the road won’t be tempted to accidentally use it again.

You can read more about anonymous structs here if you're curious.

------------------------------------------------------------------------------------------------------------------------
EMBEDDED STRUCTS
Go is not an object-oriented language. However, embedded structs provide a kind of data-only inheritance that can be useful at times. Keep in mind, Go doesn't support classes or inheritance in the complete sense, embedded structs are just a way to elevate and share fields between struct definitions.

type car struct {
  make string
  model string
}

type truck struct {
  // "car" is embedded, so the definition of a
  // "truck" now also additionally contains all
  // of the fields of the car struct
  car
  bedSize int
}

EMBEDDED VS NESTED
An embedded struct's fields are accessed at the top level, unlike nested structs.
Promoted fields can be accessed like normal fields except that they can't be used in composite literals
lanesTruck := truck{
  bedSize: 10,
  car: car{
    make: "toyota",
    model: "camry",
  },
}

fmt.Println(lanesTruck.bedSize)

// embedded fields promoted to the top-level
// instead of lanesTruck.car.make
fmt.Println(lanesTruck.make)
fmt.Println(lanesTruck.model)

------------------------------------------------------------------------------------------------------------------------

STRUCT METHODS IN GO
While Go is not object-oriented, it does support methods that can be defined on structs. Methods are just functions that have a receiver. A receiver is a special parameter that syntactically goes before the name of the function.

type rect struct {
  width int
  height int
}

// area has a receiver of (r rect)
func (r rect) area() int {
  return r.width * r.height
}

r := rect{
  width: 5,
  height: 10,
}

fmt.Println(r.area())
// prints 50

A receiver is just a special kind of function parameter. Receivers are important because they will, as you'll learn in the exercises to come, allow us to define interfaces that our structs (and other types) can implement.